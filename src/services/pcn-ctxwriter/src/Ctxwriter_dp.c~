/**
* ctxwriter API generated from ctxwriter.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/

#include <bcc/helpers.h>
/*
 * This function is called each time a packet arrives to the cube.
 * ctx contains the packet and md some additional metadata for the packet.
 * If the service is of type XDP_SKB/DRV CTX TYPE is equivalent to the struct
 * xdp_md otherwise, if the service is of type TC, CTXTYPE is equivalent to
 * the __sk_buff struct
 * Please look at the libpolycube documentation for more details.
 */
struct meta_info {
	__u32 mark;
} __attribute__((aligned(4)));


/*
 * BPF map of single element that saves the action to be applied in packets
 */
BPF_ARRAY(action_map, uint8_t, 1);


/*
 * BPF map where the ids of the ports are saved.  This module supports at most
 * two ports
 */
BPF_ARRAY(ports_map, uint16_t, 2);

enum {
  READ, //Read
  WRITE,  // Write
};

static __always_inline
int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {
  // Put your eBPF datapath code here
  pcn_log(ctx, LOG_DEBUG, "Hello from polycube! CtxWriter :-)");
  pcn_log(ctx, LOG_DEBUG, "Receiving packet from port %d", md->in_port);
  struct meta_info *meta;
  void *data, *data_end;
  int ret;

  const uint16_t UINT16_MAX = 0xffff;
  unsigned int zero = 0;
  unsigned int one = 1;


  pcn_log(ctx, LOG_DEBUG, "After Packet LookUp");
  uint8_t *action = action_map.lookup(&zero);
  if (!action) {
	  return RX_DROP;
  }
  if (*action == READ){
	  pcn_log(ctx, LOG_DEBUG, "Action: READ");
	  /* Check data_meta have room for meta_info struct */
	  data = (void *)(unsigned long)ctx->data;
	  meta = (void *)(unsigned long)ctx->data_meta;
	  if (meta + 1 > data){
	    pcn_log(ctx, LOG_DEBUG, "NO METADATA");
	    // DO NOT DROP IF YOU JUST WANT TO PASS NEXT PORT 
	    return RX_DROP;
	  } else{
	    pcn_log(ctx, LOG_DEBUG, "READ MARK = %d", meta->mark);
	  }
  } else{
	  pcn_log(ctx, LOG_DEBUG, "Action: Write");

	  /* Reserve space in-front of data pointer for our meta info.
	   * (Notice drivers not supporting data_meta will fail here!)
	   */
	  ret = bpf_xdp_adjust_meta(ctx, -(int)sizeof(*meta));
	  if (ret < 0){
	     pcn_log(ctx, LOG_DEBUG, "ABORTED DUE TO META");
	     return RX_DROP;

	  }
	
	  /* Notice: Kernel-side verifier requires that loading of
	   * ctx->data MUST happen _after_ helper bpf_xdp_adjust_meta(),
	   * as pkt-data pointers are invalidated.  Helpers that require
	   * this are determined/marked by bpf_helper_changes_pkt_data()
	   */
	  /* Check data_meta have room for meta_info struct */
	  data = (void *)(unsigned long)ctx->data;
	  meta = (void *)(unsigned long)ctx->data_meta;
	  if (meta + 1 > data){
	    pcn_log(ctx, LOG_DEBUG, "ABORTED IN WRITE");
	    return RX_DROP;
	  }
	  

	  meta->mark = 42;
  }

  uint16_t *p1 = ports_map.lookup(&zero);
  if (!p1 || *p1 == UINT16_MAX) {
    return RX_DROP;
  }

  pcn_log(ctx, LOG_DEBUG, "p1 = %d",*p1);

  uint16_t *p2 = ports_map.lookup(&one);
  if (!p2 || *p2 == UINT16_MAX) {
    return RX_DROP;
  }

  pcn_log(ctx, LOG_DEBUG, "p2 = %d",*p2);

  pcn_log(ctx, LOG_DEBUG, "Forwarding packet");

  uint16_t outport = md->in_port == *p1 ? *p2 : *p1;
  pcn_log(ctx, LOG_DEBUG, "OUTPORT Set to %d",outport);

  return pcn_pkt_redirect(ctx, md, outport);

  
   
  
}
