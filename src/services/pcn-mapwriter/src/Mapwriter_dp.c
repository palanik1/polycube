/**
* mapwriter API generated from mapwriter.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/

#include <uapi/linux/ip.h>
#include <uapi/linux/udp.h>

#define IPPROTO_TCP 6
#define IPPROTO_UDP 17

struct packetHeaders {
  uint32_t srcIp;
  uint32_t dstIp;
  uint8_t l4proto;
  uint16_t srcPort;
  uint16_t dstPort;
  uint8_t flags;
  uint32_t seqN;
  uint32_t ackN;
  uint8_t connStatus;
};

struct eth_hdr {
  __be64 dst : 48;
  __be64 src : 48;
  __be16 proto;
} __attribute__((packed));

/*The struct defined in tcp.h lets flags be accessed only one by one,
*it is not needed here.*/
struct tcp_hdr {
  __be16 source;
  __be16 dest;
  __be32 seq;
  __be32 ack_seq;
  __u8 res1 : 4, doff : 4;
  __u8 flags;
  __be16 window;
  __sum16 check;
  __be16 urg_ptr;
} __attribute__((packed));


// This is the percpu array containing the current packet headers

BPF_TABLE_SHARED("percpu_array", int, struct packetHeaders, packetData, 1);
//BPF_TABLE_PUBLIC("percpu_array", int, struct packetHeaders, packet, 1);
//BPF_TABLE_PINNED("percpu_array", int, struct packetHeaders, packet, 1,"/sys/fs/bpf/mapwriter");

/*
 * BPF map of single element that saves the action to be applied in packets
 */
BPF_ARRAY(action_map, uint8_t, 1);


/*
 * BPF map where the ids of the ports are saved.  This module supports at most
 * two ports
 */
BPF_ARRAY(ports_map, uint16_t, 2);

enum {
  READ, //Read
  WRITE,  // Write
};


static __always_inline
int update_map(void * data, void * data_end, struct iphdr *ip,struct packetHeaders *pkt) {
  
  pkt->srcIp = ip->saddr;
  pkt->dstIp = ip->daddr;
  pkt->l4proto = ip->protocol;

  if (ip->protocol == IPPROTO_TCP) {
    struct tcp_hdr *tcp = NULL;
    tcp = data + sizeof(struct eth_hdr) + sizeof(*ip);
    if (data + sizeof(struct eth_hdr) + sizeof(*ip) + sizeof(*tcp) > data_end)
      return RX_DROP;
    pkt->srcPort = tcp->source;
    pkt->dstPort = tcp->dest;
    pkt->seqN = tcp->seq;
    pkt->ackN = tcp->ack_seq;
    pkt->flags = tcp->flags;
  } else if (ip->protocol == IPPROTO_UDP) {

    struct udphdr *udp = NULL;
    udp = data + sizeof(struct eth_hdr) + sizeof(*ip);
    if (data + sizeof(struct eth_hdr) + sizeof(*ip) + sizeof(*udp) > data_end)
      return RX_DROP;
    pkt->srcPort = udp->source;
    pkt->dstPort = udp->dest;
  }

}


/*
 * This function is called each time a packet arrives to the cube.
 * ctx contains the packet and md some additional metadata for the packet.
 * If the service is of type XDP_SKB/DRV CTX TYPE is equivalent to the struct
 * xdp_md otherwise, if the service is of type TC, CTXTYPE is equivalent to
 * the __sk_buff struct
 * Please look at the libpolycube documentation for more details.
 */


static __always_inline
int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {
  // Put your eBPF datapath code here
  const uint16_t UINT16_MAX = 0xffff;
  unsigned int zero = 0;
  unsigned int one = 1;

  pcn_log(ctx, LOG_DEBUG, "Hello from IRL MapWriter polycube! :-)");
  pcn_log(ctx, LOG_DEBUG, "Receiving packet from port %d", md->in_port);

  void *data = (void *)(long)ctx->data;
  void *data_end = (void *)(long)ctx->data_end;
  struct eth_hdr *ethernet = data;
  if (data + sizeof(*ethernet) > data_end)
    return RX_DROP;

  struct iphdr *ip = NULL;
  ip = data + sizeof(struct eth_hdr);
  if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)
    return RX_DROP;

  int key = 0;
  struct packetHeaders *pkt;

  pcn_log(ctx, LOG_DEBUG, "Before Packet LookUp");
  pkt = packetData.lookup(&key);
  if (pkt == NULL) {
    pcn_log(ctx, LOG_DEBUG, "Packet is NULL");
    // Not possible
    return RX_DROP;
  }
  pcn_log(ctx, LOG_DEBUG, "After Packet LookUp");
  uint8_t *action = action_map.lookup(&zero);
  if (!action) {
    return RX_DROP;
  }
  if (*action == READ){
    pcn_log(ctx, LOG_DEBUG, "Action: READ");
    pcn_log(ctx, LOG_DEBUG, "READ SRCIP = %d", pkt->srcIp);
    pcn_log(ctx, LOG_DEBUG, "READ DSTIP = %d", pkt->dstIp);

  } else{
    pcn_log(ctx, LOG_DEBUG, "Action: Write");
    update_map(data,data_end,ip,pkt);
  }
  

  /*
  
  pkt->srcIp = ip->saddr;
  pkt->dstIp = ip->daddr;
  pkt->l4proto = ip->protocol;

  if (ip->protocol == IPPROTO_TCP) {
    struct tcp_hdr *tcp = NULL;
    tcp = data + sizeof(struct eth_hdr) + sizeof(*ip);
    if (data + sizeof(struct eth_hdr) + sizeof(*ip) + sizeof(*tcp) > data_end)
      return RX_DROP;
    pkt->srcPort = tcp->source;
    pkt->dstPort = tcp->dest;
    pkt->seqN = tcp->seq;
    pkt->ackN = tcp->ack_seq;
    pkt->flags = tcp->flags;
  } else if (ip->protocol == IPPROTO_UDP) {

    struct udphdr *udp = NULL;
    udp = data + sizeof(struct eth_hdr) + sizeof(*ip);
    if (data + sizeof(struct eth_hdr) + sizeof(*ip) + sizeof(*udp) > data_end)
      return RX_DROP;
    pkt->srcPort = udp->source;
    pkt->dstPort = udp->dest;
  }
  */
    uint16_t *p1 = ports_map.lookup(&zero);
    if (!p1 || *p1 == UINT16_MAX) {
      return RX_DROP;
    }

    pcn_log(ctx, LOG_DEBUG, "p1 = %d",*p1);

    uint16_t *p2 = ports_map.lookup(&one);
    if (!p2 || *p2 == UINT16_MAX) {
      return RX_DROP;
    }

    pcn_log(ctx, LOG_DEBUG, "p2 = %d",*p2);

    pcn_log(ctx, LOG_DEBUG, "Forwarding packet");

    uint16_t outport = md->in_port == *p1 ? *p2 : *p1;
    pcn_log(ctx, LOG_DEBUG, "OUTPORT Set to %d",outport);
    
    return pcn_pkt_redirect(ctx, md, outport);
    //return RX_DROP;
    //return RX_OK;
  

}

