/**
* mapwriter API generated from mapwriter.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/

#include <uapi/linux/ip.h>
#include <uapi/linux/udp.h>

struct meta_info {
	__u32 mark;
} __attribute__((aligned(4)));


// This is the percpu array containing the current packet headers

BPF_TABLE_SHARED("percpu_array", int, struct meta_info, meta, 1);
//BPF_TABLE_PUBLIC("percpu_array", int, struct packetHeaders, packet, 1);
//BPF_TABLE_PINNED("percpu_array", int, struct packetHeaders, packet, 1,"/sys/fs/bpf/mapwriter");

/*
 * BPF map of single element that saves the action to be applied in packets
 */
BPF_ARRAY(action_map, uint8_t, 1);


/*
 * BPF map where the ids of the ports are saved.  This module supports at most
 * two ports
 */
BPF_ARRAY(ports_map, uint16_t, 2);

enum {
  READ, //Read
  WRITE,  // Write
};

/*
 * This function is called each time a packet arrives to the cube.
 * ctx contains the packet and md some additional metadata for the packet.
 * If the service is of type XDP_SKB/DRV CTX TYPE is equivalent to the struct
 * xdp_md otherwise, if the service is of type TC, CTXTYPE is equivalent to
 * the __sk_buff struct
 * Please look at the libpolycube documentation for more details.
 */


static __always_inline
int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {
  // Put your eBPF datapath code here
  const uint16_t UINT16_MAX = 0xffff;
  unsigned int zero = 0;
  unsigned int one = 1;

  //pcn_log(ctx, LOG_DEBUG, "Hello from IRL MapWriter polycube! :-)");
  //pcn_log(ctx, LOG_DEBUG, "Receiving packet from port %d", md->in_port);

  int key = 0;
  struct meta_info *pkt;

  //pcn_log(ctx, LOG_DEBUG, "Before Packet LookUp");
  pkt = meta.lookup(&key);
  if (pkt == NULL) {
    //pcn_log(ctx, LOG_DEBUG, "Packet is NULL");
    // Not possible
    return RX_DROP;
  }
  //pcn_log(ctx, LOG_DEBUG, "After Packet LookUp");
  uint8_t *action = action_map.lookup(&zero);
  if (!action) {
    return RX_DROP;
  }
  if (*action == READ){
    //pcn_log(ctx, LOG_DEBUG, "Action: READ");
    //pcn_log(ctx, LOG_DEBUG, "READ MARK = %d", pkt->mark);
  } else {
    //pcn_log(ctx, LOG_DEBUG, "Action: Write");
    pkt->mark=42;
  }
  
    uint16_t *p1 = ports_map.lookup(&zero);
    if (!p1 || *p1 == UINT16_MAX) {
      return RX_DROP;
    }

    //pcn_log(ctx, LOG_DEBUG, "p1 = %d",*p1);

    uint16_t *p2 = ports_map.lookup(&one);
    if (!p2 || *p2 == UINT16_MAX) {
      return RX_DROP;
    }

    //pcn_log(ctx, LOG_DEBUG, "p2 = %d",*p2);

    //pcn_log(ctx, LOG_DEBUG, "Forwarding packet");

    uint16_t outport = md->in_port == *p1 ? *p2 : *p1;
    //pcn_log(ctx, LOG_DEBUG, "OUTPORT Set to %d",outport);
    
    return pcn_pkt_redirect(ctx, md, outport);
    //return RX_DROP;
    //return RX_OK;
  

}

